#include "Assets/Scripts/CS/Math.compute"

RWStructuredBuffer<uint> Permutations;

float GenerateSimplexNoise(float x, float y)
{
	float F2 = 0.366025403;
	float G2 = 0.211324865;

	float n0, n1, n2;

	float s = (x + y) * F2;
	float xs = x + s;
	float ys = y + s;
	uint i = fastFloor(xs);
	uint j = fastFloor(ys);

	float t = (float)(i + j) * G2;
	float X0 = i - t;
	float Y0 = j - t;
	float x0 = x - X0;
	float y0 = y - Y0;

	uint i1, j1;

	if (x0 > y0) {
		i1 = 1;
		j1 = 0;
	}
	else {
		i1 = 0;
		j1 = 1;
	}

	float x1 = x0 - i1 + G2;
	float y1 = y0 - j1 + G2;
	float x2 = x0 - 1.0 + 2.0 * G2;
	float y2 = y0 - 1.0 + 2.0 * G2;

	uint ii = i % 256;
	uint jj = j % 256;

	float t0 = 0.5 - x0 * x0 - y0 * y0;

	if (t0 < 0.0)
	{
		n0 = 0.0;
	}
	else
	{
		t0 *= t0;
		n0 = t0 * t0 * grad(Permutations[ii + Permutations[jj]], x0, y0);
	}

	float t1 = 0.5 - x1 * x1 - y1 * y1;

	if (t1 < 0.0)
	{
		n1 = 0.0;
	}
	else
	{
		t1 *= t1;
		n1 = t1 * t1 * grad(Permutations[ii + i1 + Permutations[jj + j1]], x1, y1);
	}

	float t2 = 0.5 - x2 * x2 - y2 * y2;

	if (t2 < 0.0) {
		n2 = 0.0;
	}
	else
	{
		t2 *= t2;
		n2 = t2 * t2 * grad(Permutations[ii + 1 + Permutations[jj + 1]], x2, y2);
	}

	return 40.0 * (n0 + n1 + n2);
}

float GenerateSimplexNoise(float x, float y, float z)
{
	// Simple skewing factors for the 3D case
	const float F3 = 0.333333333;
	const float G3 = 0.166666667;

	float n0, n1, n2, n3; // Noise contributions from the four corners

	// Skew the input space to determine which simplex cell we're in
	float s = (x + y + z) * F3; // Very nice and simple skew factor for 3D
	float xs = x + s;
	float ys = y + s;
	float zs = z + s;
	uint i = fastFloor(xs);
	uint j = fastFloor(ys);
	uint k = fastFloor(zs);

	float t = (float)(i + j + k) * G3;
	float X0 = i - t; // Unskew the cell origin back to (x,y,z) space
	float Y0 = j - t;
	float Z0 = k - t;
	float x0 = x - X0; // The x,y,z distances from the cell origin
	float y0 = y - Y0;
	float z0 = z - Z0;

	// For the 3D case, the simplex shape is a slightly irregular tetrahedron.
	// Determine which simplex we are in.
	uint i1, j1, k1; // Offsets for second corner of simplex in (i,j,k) coords
	uint i2, j2, k2; // Offsets for third corner of simplex in (i,j,k) coords

	/* This code would benefit from a backport from the GLSL version! */
	if (x0 >= y0) {
		if (y0 >= z0)
		{
			i1 = 1; j1 = 0; k1 = 0; i2 = 1; j2 = 1; k2 = 0;
		} // X Y Z order
		else if (x0 >= z0) { i1 = 1; j1 = 0; k1 = 0; i2 = 1; j2 = 0; k2 = 1; } // X Z Y order
		else { i1 = 0; j1 = 0; k1 = 1; i2 = 1; j2 = 0; k2 = 1; } // Z X Y order
	}
	else { // x0<y0
		if (y0 < z0) { i1 = 0; j1 = 0; k1 = 1; i2 = 0; j2 = 1; k2 = 1; } // Z Y X order
		else if (x0 < z0) { i1 = 0; j1 = 1; k1 = 0; i2 = 0; j2 = 1; k2 = 1; } // Y Z X order
		else { i1 = 0; j1 = 1; k1 = 0; i2 = 1; j2 = 1; k2 = 0; } // Y X Z order
	}

	// A step of (1,0,0) in (i,j,k) means a step of (1-c,-c,-c) in (x,y,z),
	// a step of (0,1,0) in (i,j,k) means a step of (-c,1-c,-c) in (x,y,z), and
	// a step of (0,0,1) in (i,j,k) means a step of (-c,-c,1-c) in (x,y,z), where
	// c = 1/6.

	float x1 = x0 - i1 + G3; // Offsets for second corner in (x,y,z) coords
	float y1 = y0 - j1 + G3;
	float z1 = z0 - k1 + G3;
	float x2 = x0 - i2 + 2.0 * G3; // Offsets for third corner in (x,y,z) coords
	float y2 = y0 - j2 + 2.0 * G3;
	float z2 = z0 - k2 + 2.0 * G3;
	float x3 = x0 - 1.0 + 3.0 * G3; // Offsets for last corner in (x,y,z) coords
	float y3 = y0 - 1.0 + 3.0 * G3;
	float z3 = z0 - 1.0 + 3.0 * G3;

	// Wrap the integer indices at 256, to avoid indexing Permutations[] out of bounds
	uint ii = mod(i, 256);
	uint jj = mod(j, 256);
	uint kk = mod(k, 256);

	// Calculate the contribution from the four corners
	float t0 = 0.6 - x0 * x0 - y0 * y0 - z0 * z0;
	if (t0 < 0.0) n0 = 0.0;
	else {
		t0 *= t0;
		n0 = t0 * t0 * grad(Permutations[ii + Permutations[jj + Permutations[kk]]], x0, y0, z0);
	}

	float t1 = 0.6 - x1 * x1 - y1 * y1 - z1 * z1;
	if (t1 < 0.0) n1 = 0.0;
	else {
		t1 *= t1;
		n1 = t1 * t1 * grad(Permutations[ii + i1 + Permutations[jj + j1 + Permutations[kk + k1]]], x1, y1, z1);
	}

	float t2 = 0.6 - x2 * x2 - y2 * y2 - z2 * z2;
	if (t2 < 0.0) n2 = 0.0;
	else {
		t2 *= t2;
		n2 = t2 * t2 * grad(Permutations[ii + i2 + Permutations[jj + j2 + Permutations[kk + k2]]], x2, y2, z2);
	}

	float t3 = 0.6 - x3 * x3 - y3 * y3 - z3 * z3;
	if (t3 < 0.0) n3 = 0.0;
	else {
		t3 *= t3;
		n3 = t3 * t3 * grad(Permutations[ii + 1 + Permutations[jj + 1 + Permutations[kk + 1]]], x3, y3, z3);
	}

	// Add contributions from each corner to get the final noise value.
	// The result is scaled to stay just inside [-1,1]
	return 32.0 * (n0 + n1 + n2 + n3); // TODO: The scale factor is preliminary!
}

float GeneratePerlinNoise(float x, float y, float z)
{
	uint xi = (uint)x & 255;                              // Calculate the "unit cube" that the point asked will be located in
	uint yi = (uint)y & 255;                              // The left bound is ( |_x_|,|_y_|,|_z_| ) and the right bound is that
	uint zi = (uint)z & 255;                              // plus 1.  Next we calculate the location (from 0.0 to 1.0) in that cube.
	float xf = x - (uint)x;                             // We also fade the location to smooth the result.
	float yf = y - (uint)y;

	float zf = z - (uint)z;
	float u = fade(xf);
	float v = fade(yf);
	float w = fade(zf);

	uint aaa, aba, aab, abb, baa, bba, bab, bbb;
	aaa = Permutations[Permutations[Permutations[xi] + yi] + zi];
	aba = Permutations[Permutations[Permutations[xi] + inc(yi)] + zi];
	aab = Permutations[Permutations[Permutations[xi] + yi] + inc(zi)];
	abb = Permutations[Permutations[Permutations[xi] + inc(yi)] + inc(zi)];
	baa = Permutations[Permutations[Permutations[inc(xi)] + yi] + zi];
	bba = Permutations[Permutations[Permutations[inc(xi)] + inc(yi)] + zi];
	bab = Permutations[Permutations[Permutations[inc(xi)] + yi] + inc(zi)];
	bbb = Permutations[Permutations[Permutations[inc(xi)] + inc(yi)] + inc(zi)];

	float x1, x2, y1, y2;
	x1 = lerp(grad(aaa, xf, yf, zf),                // The gradient function calculates the dot product between a pseudorandom
		grad(baa, xf - 1, yf, zf),              // gradient vector and the vector from the input coordinate to the 8
		u);                                     // surrounding points in its unit cube.
	x2 = lerp(grad(aba, xf, yf - 1, zf),                // This is all then lerped together as a sort of weighted average based on the faded (u,v,w)
		grad(bba, xf - 1, yf - 1, zf),              // values we made earlier.
		u);
	y1 = lerp(x1, x2, v);

	x1 = lerp(grad(aab, xf, yf, zf - 1),
		grad(bab, xf - 1, yf, zf - 1),
		u);
	x2 = lerp(grad(abb, xf, yf - 1, zf - 1),
		grad(bbb, xf - 1, yf - 1, zf - 1),
		u);
	y2 = lerp(x1, x2, v);

	return (lerp(y1, y2, w) + 1) / 2;                       // For convenience we bound it to 0 - 1 (theoretical min/max before is -1 - 1)
}